package analysis

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"slices"
	"strconv"
	"strings"
	"text/template"

	"github.com/zjutjh/gbc/comm"
)

const fileTemplate = `// Code generated by {{ quote .Generator }}. DO NOT EDIT.

//go:build !gbc_generate_exclude

package {{.PackageName}}

import (
	"github.com/zjutjh/mygo/kit"
	"github.com/zjutjh/mygo/swagger"

	"app/comm"
)

func init() {
	{{ range $i, $handler := .Handlers }}
	{{- if ne $i 0 }}

	{{ end -}}
	// {{ $handler.FilePos }}
	{
		statusCodes := []kit.Code{
			{{- range $i, $status := $handler.StatusCodeMap }}
			comm.{{ $status.Code }},
			{{- end }}
		}
		swagger.MustRegisterBusinessStatusCodes({{ quote $handler.FullName }}, statusCodes)
	}
	{{- end }}
}
`

var tmpl *template.Template

func loadStatusCodesAndTemplate() error {
	funcMap := template.FuncMap{
		"quote": strconv.Quote,
	}
	var err error
	tmpl, err = template.New("fileTemplate").Funcs(funcMap).Parse(fileTemplate)
	if err != nil {
		return err
	}
	return nil
}

type statusCodeInfo struct {
	Code string
}

type handlerInfo struct {
	FullName      string
	FilePos       string
	StatusCodeMap []statusCodeInfo
}

type fileInfo struct {
	Generator   string
	PackageName string
	Handlers    []handlerInfo
}

func removePathPrefix(path, prefix string) string {
	if strings.HasPrefix(path, prefix) {
		return strings.TrimPrefix(path[len(prefix):], "/")
	}
	return path
}

func GenerateInitialFiles(moduleName string, infos map[string][]*GinHandlerInfo, storeDir string) error {
	comm.OutputInfo("开始生成 status_codes_generated.go 文件")
	var packageName string
	if storeDir == "" {
		packageName = "main"
	} else {
		packageName = filepath.Base(storeDir)
	}
	fileInfo := fileInfo{
		Generator:   "gbc codegen",
		PackageName: packageName,
		Handlers:    make([]handlerInfo, 0),
	}
	for pkgPath, pkgInfos := range infos {
		// 确认当前的路径在当前模块下面（只维护当前模块自己的处理器状态码）
		if !strings.HasPrefix(pkgPath, moduleName) {
			continue
		}
		slices.SortFunc(pkgInfos, func(a, b *GinHandlerInfo) int {
			return strings.Compare(a.HandlerName, b.HandlerName)
		})
		for _, pkgInfo := range pkgInfos {
			if len(pkgInfo.StatusCodes) == 0 {
				continue
			}
			statusCodeMap := make([]statusCodeInfo, 0, len(pkgInfo.StatusCodes))
			for _, statusCode := range pkgInfo.StatusCodes {
				statusCodeMap = append(statusCodeMap, statusCodeInfo{
					Code: statusCode,
				})
			}
			// 处理器的文件路径
			filePos := removePathPrefix(pkgInfo.FileName, moduleName)
			filePos = fmt.Sprintf("%s:%d", filePos, pkgInfo.StartPos)
			fileInfo.Handlers = append(fileInfo.Handlers, handlerInfo{
				FullName:      pkgInfo.HandlerName,
				FilePos:       filePos,
				StatusCodeMap: statusCodeMap,
			})
		}
	}
	slices.SortFunc(fileInfo.Handlers, func(a, b handlerInfo) int {
		return strings.Compare(a.FullName, b.FullName)
	})
	filePath := filepath.Join(storeDir, "status_codes_generated.go")
	buffer := bytes.Buffer{}
	err := tmpl.Execute(&buffer, fileInfo)
	if err != nil {
		return fmt.Errorf("生成文件失败: %w", err)
	}
	// format source file
	raw, err := format.Source(buffer.Bytes())
	if err != nil {
		return fmt.Errorf("格式化代码失败: %w", err)
	}
	comm.OutputInfo("文件路径：%s", filePath)
	file, err := os.OpenFile(filePath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644)
	if err != nil {
		return fmt.Errorf("打开文件失败: %w", err)
	}
	defer file.Close()
	_, err = file.Write(raw)
	if err != nil {
		return fmt.Errorf("写入文件失败: %w", err)
	}
	comm.OutputInfo("结束生成文件")
	return nil
}
